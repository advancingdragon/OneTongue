ometa OneTranslator {
    oper = 'Mul' | 'Div' | 'Mod'
         | 'Add' | 'Sub'
         | 'Concat'
         | 'Eq' | 'Ne' | 'Lt' | 'Gt' | 'Le' | 'Ge'
         | 'And'
         | 'Or',

    expr :dest = char:x
                 emitChar(x):c
                 -> (dest + " = oneNewChar(" + c + ");\n")

               | number:x
                 -> (dest + " = oneNewInt(" + x.toString() + ");\n")

               | [ 'list' [ genVar(0):v expr(v)*:xs ] ]
                 ( -> (xs.concat([""])) ):xs
                 -> (dest + " = oneNewList();\n" +
                     xs.join("oneAppend(" + dest + ", " + v + ");\n"))

               | [ 'var' string:n ]
                 -> (dest + " = " + n + ";\n")

               | [ 'call' string:n
                   ( -> "" ):xs
                   ( -> "" ):args
                   (
                     genVar(0):v expr(v):x
                     ( -> x ):xs
                     ( -> v ):args
                     (
                       genVar(0):v expr(v):x
                       ( -> (xs + x) ):xs
                       ( -> (args + ", " + v) ):args
                     )*
                   )?
                 ]
                 -> (xs +
                     dest + " = one" + n + "(" + args + ");\n")

               | [ oper:op
                   genVar(0):v expr(v):x
                   genVar(0):w expr(w):y
                 ]
                 -> (x + y +
                     dest + " = one" + op + "(" + v + ", " + w + ");\n")

               | [ 'match' number:x ]
                 -> (dest + " = oneMatchInt(" + x.toString() + ");\n")

               // TODO enterList

               | [ 'enterList' expr(dest):x ]
                 -> (x)

               | [ 'matchList' [ char*:xs ] ]
                 emitString(xs.join("")):s
                 -> (dest + " = oneMatchString(" + s + ");\n")

               | [ 'not' genVar(0):v expr(v):x ]
                 -> (x +
                     dest + " = !" + v + ";\n")

               | [ 'set' [ char*:xs ]
                   ( -> (xs.join("")) ):v
                   expr(v):x ]
                 -> (x +
                     dest + " = " + v + ";\n")

               | [ 'star' genVar(0):v expr(v):x ]
                 -> (dest + " = oneNewList();\n" +
                     "do {\n" +
                     x +
                     "if (" + v + " == NIL) { break; }\n" +
                     "oneAppend(" + dest + ", " + v + ");\n" +
                     "} while (0);\n")

               | [ 'plus' genVar(0):v expr(v):x ]
                 -> (x +
                     "if (" + v + " == NIL) {\n" +
                     dest + " = NIL;\n" +
                     "} else {\n" +
                     dest + " = oneNewList();\n" +
                     "oneAppend(" + dest + ", " + v + ");\n" +
                     "do {\n" +
                     x +
                     "if (" + v + " == NIL) { break; }\n" +
                     "oneAppend(" + dest + ", " + v + ");\n" +
                     "} while (0);\n" +
                     "}\n")

               | [ 'opt' genVar(0):v expr(v):x ]
                 -> (dest + " = oneNewList();\n" +
                     x +
                     "if (" + v + " != NIL) {\n" +
                     "oneAppend(" + dest + ", " + v + ");\n" +
                     "}\n")

               | [ 'sideSeq' expr(dest)*:xs ]
                 -> (xs.join(""))

               | [ 'seq' expr(dest)*:xs ]
                 -> ("do {\n" +
                     xs.join("if (" + dest + " == NIL) { break; }\n") +
                     "} while (0);\n")

               // TODO backtracking

               | [ 'alt' expr(dest)*:xs ]
                 -> ("do {\n" +
                     xs.join("if (" + dest + " != NIL) { break; }\n") +
                     "} while (0);\n"),

    statement = [ 'stat' [ string:name string*:args ] expr("vRes"):x ]
                -> ("struct oneValue *one" + name +
                    "(" + this.defineArgs(args) + ")\n" +
                    "{\n" +
                    this.defineVars() +
                    x +
                    "}\n"),

    program = [ (resetCounter(0) statement)*:s ] -> s.join("\n")
}

// resetCounter takes a dummy argument to prevent memoization
OneTranslator.resetCounter = function() {
    this.apply("anything");
    this.counter = 0;
};

// genVar takes a dummy argument to prevent memoization
OneTranslator.genVar = function() {
    var r;
    this.apply("anything");
    r = "v" + this.counter.toString();
    this.counter = this.counter + 1;
    return r;
};

OneTranslator.defineVars = function() {
    var i;
    var s = "";

    for (i = 0; i < this.counter; i++) {
        s = s + "struct oneValue *" + "v" + i.toString() + ";\n";
    }
    return s;
};

OneTranslator.defineArgs = function(args) {
    var i;
    var s = "";
    
    if (args.length > 0) {
        s = "struct oneValue *" + args[0];

        for (i = 1; i < args.length; i++) {
            s = s + ", struct oneValue *" + args[i];
        }
    }

    return s;
};

OneTranslator.emitChar = function(c) {
    if (c === "'") {
        return "'\\''";
    } else if (c === "\n") {
        return "'\\n'";
    } else if (c === "\r") {
        return "'\\n'";
    } else if (c === "\t") {
        return "'\\t'";
    } else {
        return "'" + c + "'";
    }
};

OneTranslator.emitString = function(s) {
    var i;
    var result = "\"";

    for (i = 0; i < s.length; i++) {
        if (s[i] === "\"") {
            result = result + "\\\"";
        } else if (s[i] === "\n") {
            result = result + "\\n";
        } else if (s[i] === "\r") {
            result = result + "\\r";
        } else if (s[i] === "\t") {
            result = result + "\\t";
        } else {
            result = result + s[i];
        }
    }
    result = result + "\"";
    return result;
};
